{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to mlpyqtgraph's documentation!","text":"<p>mlpyqtgraph enables matplotlib-like plotting with pyqtgraph in existing python programs.</p> <p>Please refer to the  for a brief explanation of mlpyqtgraph or read the getting started to try mlpyqtgraph out right away.</p>"},{"location":"examples/","title":"Examples","text":"<p>Please refer to the examples directory for a series of examples that illustrate usage of mlpyqtgraph.</p>"},{"location":"getting_started/","title":"Getting started","text":"<p>To get started using mlpyqtgraph, it first needs to be installed. Refer to installation page for instructions.</p> <p>Now, mlpyqtgraph can be used in existing python programs.</p> <p>To get started, try out the full example from the mlpyqtgraph examples.</p> <pre><code>import numpy as np\nimport mlpyqtgraph as mpg\n\n\n@mpg.plotter\ndef main():\n    \"\"\" Advanced mlpyqtgraph example \"\"\"\n    plot_args = {'width': 2}\n\n    fig = mpg.figure(title='Another figure')\n    fig.width = 600\n    theta = np.linspace(0, 2*np.pi, 100)\n    mpg.plot(theta, np.cos(theta), **plot_args)\n    mpg.plot(theta, np.sin(theta), **plot_args)\n    mpg.plot(theta, np.sin(theta + np.pi), style='--', **plot_args)\n    mpg.plot(theta, np.cos(theta + np.pi), style='.-', **plot_args)\n    mpg.plot(theta, 0.5*np.cos(theta), color='k', **plot_args)\n    axis = mpg.gca()\n    axis.grid = True\n    axis.xlabel = 'x'\n    axis.ylabel = 'y'\n    axis.xticks = (\n        (0.0, '0'),\n        (np.pi/2.0, '\u03c0/2'),\n        (np.pi, '\u03c0'),\n        (1.5*np.pi, '3\u03c0/2'),\n        (2.0*np.pi, '2\u03c0'),\n    )\n    axis.add_legend(\n        'y=cos(x)',\n        'y=sin(x)',\n        'y=sin(x+\u03c0)',\n        'y=cos(x+\u03c0)',\n        'y=cos(x)/2',\n    )\n\n\nif __name__ == '__main__':\n    main()\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p>mlpyqtgraph is a python package which is available on the Python Package Index (PyPi). You can install it just like any other python package using <code>pip</code>:</p> <pre><code>pip install mlpyqtgraph\n</code></pre> <p>Alternatively, you can install mlpyqtgraph directly from source. To do this, first clone the package from GitHub using <code>git</code>:</p> <pre><code>git clone https://github.com/swvanbuuren/mlpyqtgraph.git\n</code></pre> <p>It is recommended to install the mlpyqtgraph package into a virtual enviroment, e.g. <code>venv</code>. Refer to its refence documentation for more details on its creation and usage.</p> <p>After the virtual environment has been created and activated, install the mlpyqtgraph package using e.g. <code>pip</code>:</p> <pre><code>pip install /path/to/mlpyqtgraph\n</code></pre> <p>Now, mpyqtgraph can be used whenever the appropriate virtual environment has been activated e.g., by trying the minimal example:</p> <pre><code>python examples/minimal.py\n</code></pre> <p>Info</p> <p>If you receive an error message similar to the following:</p> <pre><code>Could not load the Qt platform plugin \"xcb\" in \"\" even though it was found.\"\n</code></pre> <p>Then, you might need to install additional dependencies. On a Debian-based  system, this is accomplished with:</p> <pre><code>sudo apt install -y libxcb-cursor-dev\n</code></pre>"},{"location":"introduction/","title":"Introduction","text":"<p>mlpyqtgraph enables matplotlib-like plotting with pyqtgraph in existing python programs.</p> <p>It accomplishes this, by offering an interface very similar to matplotlib, while maintaining key pyqtgraph features such as speed and interactivity.</p> <p>mlpyqtgraph diverts the existing python program into a dedicated thread, while using the main thread solely for plotting with pyqtgraph. This is a requirement of Qt: the Graphical User Interface (GUI) is required to run in the main thread (also known as the \"GUI thread\").</p> <p>This is facilitated using the python package pqthreads, which exposes class interfaces from the main GUI Thread in another <code>QThread</code> in Qt for Python (PySide). In doing so, it facilitates communication between the main (GUI) thread and a dedicated <code>QThread</code>s as offered by Qt for Python.</p> <p>The following example illustrates how mlpyqtgraph can be used in an existing python program defined in <code>main</code>. The decorator takes care of diverting all code within the function it decorates into a separate <code>QThead</code>. mlpyqtgraph functionality is only available inside the decorated function and any of the function it calls.</p> <pre><code>import mlpyqtgraph as mpg\n\n\n@mpg.plotter\ndef main():\n    \"\"\" Minimal mlpyqtgraph example \"\"\"\n    mpg.plot(range(5), (1, 3, 2, 0, 5))\n\n\nif __name__ == '__main__':\n    main()\n</code></pre>"},{"location":"reference/","title":"Code Reference","text":"<p>This section features the Code reference of each module.</p>"},{"location":"reference/axes/","title":"Axes","text":"<p>mlpyqtgraph axes module, with 2D and 3D Axis classes</p>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis","title":"<code>Axis</code>","text":"<p>General Axis class, creates either 2D or 3D axis</p> Source code in <code>mlpyqtgraph/axes.py</code> <pre><code>class Axis:\n    \"\"\" General Axis class, creates either 2D or 3D axis \"\"\"\n    def __new__(cls, *args, **kwargs):\n        axis_type = kwargs.pop('axis_type', '2D')\n        if axis_type == '2D':\n            return Axis2D(*args, **kwargs)\n        if axis_type == '3D':\n            return Axis3D(*args, **kwargs)\n        raise InvalidAxis(f'Invalid Axis Type: {axis_type}. Should be either 2D or 3D')\n</code></pre>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis2D","title":"<code>Axis2D</code>","text":"<p>               Bases: <code>PlotItem</code></p> <p>Axis for plots in a given figure layout</p> Source code in <code>mlpyqtgraph/axes.py</code> <pre><code>class Axis2D(PlotItem):  # noqa: PLR0904\n    \"\"\" Axis for plots in a given figure layout \"\"\"\n    pen_styles = {'-': QtCore.Qt.SolidLine,\n                  '--': QtCore.Qt.DashLine,\n                  ':': QtCore.Qt.DotLine,\n                  '.-': QtCore.Qt.DashDotLine}\n\n    def __init__(self, index, **kwargs):\n        parent = kwargs.pop('parent', None)\n        super().__init__(parent=parent, **kwargs)\n        self.index = index\n        self.colors_defs = colors.ColorDefinitions()\n        self.line_colors = self.colors_defs.get_line_colors()\n        self.scale_box_line_color = \\\n            self.colors_defs.get_scale_box_colors(part='line')\n        self.scale_box_fill_color = \\\n            self.colors_defs.get_scale_box_colors(part='fill')\n        self.setup()\n\n    def setup(self, padding=0.01):\n        \"\"\" Setup axes and grid \"\"\"\n        self.show_axis_border('right')\n        self.show_axis_border('top')\n        self.getViewBox().setDefaultPadding(padding=padding)\n        self.getViewBox().rbScaleBox.setPen(fn.mkPen(self.scale_box_line_color, width=2))\n        self.getViewBox().rbScaleBox.setBrush(fn.mkBrush(*self.scale_box_fill_color))\n        for axis_key in self.axes:\n            self.getAxis(axis_key).setZValue(-1) # force axis and corresponding ticks to background\n\n    @property\n    def x_axis(self):\n        \"\"\" Returns the x-axis \"\"\"\n        return self.getAxis('bottom')\n\n    @property\n    def y_axis(self):\n        \"\"\" Returns the y-axis \"\"\"\n        return self.getAxis('left')\n\n    def show_axis_border(self, axis):\n        \"\"\" Enables/shows an axis, wihtout values and ticks\n\n        Parameters:\n            axis: axis string designation, 'left', 'top', 'right' or 'bottom'\n        \"\"\"\n        self.showAxis(axis, show=True)\n        self.getAxis(axis).setStyle(showValues=False)\n        self.getAxis(axis).setTicks([(),()])\n\n    def get_line_color(self, index=None):\n        \"\"\" Generate line color for given index \"\"\"\n        return self.line_colors[index % len(self.line_colors)]\n\n    def default_line_color(self):\n        \"\"\" Returns next available color, based on the number of plotted lines \"\"\"\n        return self.get_line_color(len(self.listDataItems()))\n\n    @staticmethod\n    def fix_line_artifacts(width, color):\n        \"\"\"\n        Fall to conventional slower drawing method by settings alpha &lt; 1\n\n        pyqtgraph pull request #2011 introduced a new (experimental) line\n        drawing mode for thick lines. This also leads to unwanted line artifacts\n        if antialiasing is enabled. This method causes a fallback to the old\n        (slower) drawing method.\n        \"\"\"\n        if width &gt; 1:\n            if color in fn.Colors:\n                qcolor = fn.Colors[color]\n                color = (qcolor.red(), qcolor.green(), qcolor.blue())\n            return color[:3] + (254,)\n        return color\n\n    def add(self, x_coord: np.ndarray, y_coord: np.ndarray, **kwargs):\n        \"\"\"Add a line to the Axes\n\n        Arguments:\n            x_coord:\n                x coordinates\n            y_coord:\n                y coordinates\n\n        Keyword arguments:\n            color:\n                line color, default value will determine using\n                [`default_line_color`](./#mlpyqtgraph.axes.Axis2D.default_line_color)\n            style:\n                line style\n            width:\n                line width\n            symbol:\n                symbol type symbol_size: symbol size\n            symbol_color:\n                symbol color\n\n        \"\"\"\n        color = kwargs.get('color', self.default_line_color())\n        width = kwargs.get('width', 2.0)\n        if options.get_option('no_segmented_line_mode'):\n            color = self.fix_line_artifacts(width, color)\n        style = kwargs.get('style', '-')\n        symbol = kwargs.get('symbol')\n        symbol_size = kwargs.get('symbol_size', 5)\n        symbol_color = kwargs.get('symbol_color', 'k')\n\n        line_pen = None\n        if width &gt; 0:\n            line_pen = mkPen(color, width=width)\n            if style:\n                line_pen.setStyle(self.pen_styles[style])\n\n        symbol_pen = None\n        if symbol is not None:\n            symbol_pen = mkPen(symbol_color, width=0)\n\n        self.plot(x_coord, y_coord,\n                  pen=line_pen, symbol=symbol, symbolSize=symbol_size,\n                  symbolPen=symbol_pen, symbolBrush=symbol_color)\n\n    @property\n    def grid(self):\n        \"\"\" Returns grid activation state \"\"\"\n        return self.ctrl.xGridCheck.isChecked() and self.ctrl.yGridCheck.isChecked()\n\n    @grid.setter\n    def grid(self, active=False):\n        \"\"\" Set gris activation \"\"\"\n        self.showGrid(x=active, y=active, alpha=0.5)\n\n    @property\n    def xlim(self):\n        \"\"\" Obtain xlimits \"\"\"\n        return self.x_axis.range\n\n    @xlim.setter\n    def xlim(self, limits):\n        \"\"\" Change x limits \"\"\"\n        self.setLimits(xMin=limits[0], xMax=limits[1])\n        self.setRange(xRange=limits)\n\n    @property\n    def ylim(self):\n        \"\"\" Obtain ylimits \"\"\"\n        return self.y_axis.range\n\n    @ylim.setter\n    def ylim(self, limits):\n        \"\"\" Change y limits \"\"\"\n        self.setLimits(yMin=limits[0], yMax=limits[1])\n        self.setRange(yRange=limits)\n\n    @property\n    def xlabel(self):\n        \"\"\" Obtain xlabel \"\"\"\n        return self.x_axis.label.toPlainText()\n\n    @xlabel.setter\n    def xlabel(self, label, units=None):\n        \"\"\" Change x label \"\"\"\n        self.x_axis.setLabel(label, units=units)\n\n    @property\n    def ylabel(self):\n        \"\"\" Obtain ylabel \"\"\"\n        return self.y_axis.label.toPlainText()\n\n    @ylabel.setter\n    def ylabel(self, label, units=None):\n        \"\"\" Change y label \"\"\"\n        self.y_axis.setLabel(label, units=units)\n\n    @property\n    def xticks(self):\n        \"\"\" Obtain x tick labels \"\"\"\n        return self.get_ticks(self.x_axis)\n\n    @xticks.setter\n    def xticks(self, major):\n        \"\"\" Change x tick labels \"\"\"\n        self.set_xticks(major)\n\n    @property\n    def yticks(self):\n        \"\"\" Obtain y tick labels \"\"\"\n        return self.get_ticks(self.y_axis)\n\n    @yticks.setter\n    def yticks(self, major):\n        \"\"\" Sets major tick labels on y-axis  \"\"\"\n        self.set_yticks(major)\n\n    def set_xticks(self, major, minor=None):\n        \"\"\" Sets the major and minor ticks on the x-axis \"\"\"\n        self.set_ticks(self.x_axis, major, minor)\n\n    def set_yticks(self, major, minor=None):\n        \"\"\" Sets the major and minor ticks on the y-axis \"\"\"\n        self.set_ticks(self.y_axis, major, minor)\n\n    @staticmethod\n    def set_ticks(axis, major, minor=None):\n        \"\"\" Sets the major and minor ticks on a given axis \"\"\"\n        if minor is None:\n            minor = ()\n        axis.setTicks([major, minor])\n\n    def add_legend(self, *legend_labels, offset=(1,1)):\n        \"\"\" Add legend labels \"\"\"\n        legend_brush = mkBrush(color=(255, 255, 255, 200))\n        self.addLegend(brush=legend_brush, verSpacing=-5, offset=offset)\n        plot_items = self.listDataItems()\n        for label, item in zip(legend_labels, plot_items):\n            self.legend.addItem(item, label)\n\n    def get_axis_span(self, axis):\n        \"\"\" Determine span of this axis \"\"\"\n        bounds = axis.mapRectFromParent(axis.geometry())\n        if axis.orientation == 'left':\n            return (bounds.topRight(), bounds.bottomRight())\n        if axis.orientation == 'right':\n            return (bounds.topLeft(), bounds.bottomLeft())\n        if axis.orientation == 'top':\n            return (bounds.bottomLeft(), bounds.bottomRight())\n        if axis.orientation == 'bottom':\n            return (bounds.topLeft(), bounds.topRight())\n        return None\n\n    def get_axis_size(self, axis):\n        \"\"\" Determine size of this axis in pixels \"\"\"\n        axis_span = self.get_axis_span(axis)\n        if axis_span is None:\n            return None\n        points = list(map(self.mapToDevice, axis_span))\n        if None in points:\n            return None\n        length_px = Point(points[1] - points[0]).length()\n        if length_px == 0:\n            return None\n        return length_px\n\n    def get_ticks(self, axis):\n        \"\"\" Obtain the tick values for a given axis \"\"\"\n        if axis._tickLevels is not None:\n            return axis._tickLevels  # return manually set ticks\n        length_px = self.get_axis_size(axis)\n        if length_px is None:\n            return []\n        tick_values = axis.tickValues(axis.range[0], axis.range[1], length_px)\n        ticks = list()\n        for (_, values) in tick_values:\n            ticks.extend(values)\n        return sorted(ticks)\n\n    def delete(self):\n        \"\"\" Closes the axis \"\"\"\n</code></pre>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis2D.grid","title":"<code>grid</code>  <code>property</code> <code>writable</code>","text":"<p>Returns grid activation state</p>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis2D.x_axis","title":"<code>x_axis</code>  <code>property</code>","text":"<p>Returns the x-axis</p>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis2D.xlabel","title":"<code>xlabel</code>  <code>property</code> <code>writable</code>","text":"<p>Obtain xlabel</p>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis2D.xlim","title":"<code>xlim</code>  <code>property</code> <code>writable</code>","text":"<p>Obtain xlimits</p>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis2D.xticks","title":"<code>xticks</code>  <code>property</code> <code>writable</code>","text":"<p>Obtain x tick labels</p>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis2D.y_axis","title":"<code>y_axis</code>  <code>property</code>","text":"<p>Returns the y-axis</p>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis2D.ylabel","title":"<code>ylabel</code>  <code>property</code> <code>writable</code>","text":"<p>Obtain ylabel</p>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis2D.ylim","title":"<code>ylim</code>  <code>property</code> <code>writable</code>","text":"<p>Obtain ylimits</p>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis2D.yticks","title":"<code>yticks</code>  <code>property</code> <code>writable</code>","text":"<p>Obtain y tick labels</p>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis2D.add","title":"<code>add(x_coord, y_coord, **kwargs)</code>","text":"<p>Add a line to the Axes</p> <p>Parameters:</p> Name Type Description Default <code>x_coord</code> <code>ndarray</code> <p>x coordinates</p> required <code>y_coord</code> <code>ndarray</code> <p>y coordinates</p> required <p>Other Parameters:</p> Name Type Description <code>color</code> <p>line color, default value will determine using <code>default_line_color</code></p> <code>style</code> <p>line style</p> <code>width</code> <p>line width</p> <code>symbol</code> <p>symbol type symbol_size: symbol size</p> <code>symbol_color</code> <p>symbol color</p> Source code in <code>mlpyqtgraph/axes.py</code> <pre><code>def add(self, x_coord: np.ndarray, y_coord: np.ndarray, **kwargs):\n    \"\"\"Add a line to the Axes\n\n    Arguments:\n        x_coord:\n            x coordinates\n        y_coord:\n            y coordinates\n\n    Keyword arguments:\n        color:\n            line color, default value will determine using\n            [`default_line_color`](./#mlpyqtgraph.axes.Axis2D.default_line_color)\n        style:\n            line style\n        width:\n            line width\n        symbol:\n            symbol type symbol_size: symbol size\n        symbol_color:\n            symbol color\n\n    \"\"\"\n    color = kwargs.get('color', self.default_line_color())\n    width = kwargs.get('width', 2.0)\n    if options.get_option('no_segmented_line_mode'):\n        color = self.fix_line_artifacts(width, color)\n    style = kwargs.get('style', '-')\n    symbol = kwargs.get('symbol')\n    symbol_size = kwargs.get('symbol_size', 5)\n    symbol_color = kwargs.get('symbol_color', 'k')\n\n    line_pen = None\n    if width &gt; 0:\n        line_pen = mkPen(color, width=width)\n        if style:\n            line_pen.setStyle(self.pen_styles[style])\n\n    symbol_pen = None\n    if symbol is not None:\n        symbol_pen = mkPen(symbol_color, width=0)\n\n    self.plot(x_coord, y_coord,\n              pen=line_pen, symbol=symbol, symbolSize=symbol_size,\n              symbolPen=symbol_pen, symbolBrush=symbol_color)\n</code></pre>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis2D.add_legend","title":"<code>add_legend(*legend_labels, offset=(1, 1))</code>","text":"<p>Add legend labels</p> Source code in <code>mlpyqtgraph/axes.py</code> <pre><code>def add_legend(self, *legend_labels, offset=(1,1)):\n    \"\"\" Add legend labels \"\"\"\n    legend_brush = mkBrush(color=(255, 255, 255, 200))\n    self.addLegend(brush=legend_brush, verSpacing=-5, offset=offset)\n    plot_items = self.listDataItems()\n    for label, item in zip(legend_labels, plot_items):\n        self.legend.addItem(item, label)\n</code></pre>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis2D.default_line_color","title":"<code>default_line_color()</code>","text":"<p>Returns next available color, based on the number of plotted lines</p> Source code in <code>mlpyqtgraph/axes.py</code> <pre><code>def default_line_color(self):\n    \"\"\" Returns next available color, based on the number of plotted lines \"\"\"\n    return self.get_line_color(len(self.listDataItems()))\n</code></pre>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis2D.delete","title":"<code>delete()</code>","text":"<p>Closes the axis</p> Source code in <code>mlpyqtgraph/axes.py</code> <pre><code>def delete(self):\n    \"\"\" Closes the axis \"\"\"\n</code></pre>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis2D.fix_line_artifacts","title":"<code>fix_line_artifacts(width, color)</code>  <code>staticmethod</code>","text":"<p>Fall to conventional slower drawing method by settings alpha &lt; 1</p> <p>pyqtgraph pull request #2011 introduced a new (experimental) line drawing mode for thick lines. This also leads to unwanted line artifacts if antialiasing is enabled. This method causes a fallback to the old (slower) drawing method.</p> Source code in <code>mlpyqtgraph/axes.py</code> <pre><code>@staticmethod\ndef fix_line_artifacts(width, color):\n    \"\"\"\n    Fall to conventional slower drawing method by settings alpha &lt; 1\n\n    pyqtgraph pull request #2011 introduced a new (experimental) line\n    drawing mode for thick lines. This also leads to unwanted line artifacts\n    if antialiasing is enabled. This method causes a fallback to the old\n    (slower) drawing method.\n    \"\"\"\n    if width &gt; 1:\n        if color in fn.Colors:\n            qcolor = fn.Colors[color]\n            color = (qcolor.red(), qcolor.green(), qcolor.blue())\n        return color[:3] + (254,)\n    return color\n</code></pre>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis2D.get_axis_size","title":"<code>get_axis_size(axis)</code>","text":"<p>Determine size of this axis in pixels</p> Source code in <code>mlpyqtgraph/axes.py</code> <pre><code>def get_axis_size(self, axis):\n    \"\"\" Determine size of this axis in pixels \"\"\"\n    axis_span = self.get_axis_span(axis)\n    if axis_span is None:\n        return None\n    points = list(map(self.mapToDevice, axis_span))\n    if None in points:\n        return None\n    length_px = Point(points[1] - points[0]).length()\n    if length_px == 0:\n        return None\n    return length_px\n</code></pre>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis2D.get_axis_span","title":"<code>get_axis_span(axis)</code>","text":"<p>Determine span of this axis</p> Source code in <code>mlpyqtgraph/axes.py</code> <pre><code>def get_axis_span(self, axis):\n    \"\"\" Determine span of this axis \"\"\"\n    bounds = axis.mapRectFromParent(axis.geometry())\n    if axis.orientation == 'left':\n        return (bounds.topRight(), bounds.bottomRight())\n    if axis.orientation == 'right':\n        return (bounds.topLeft(), bounds.bottomLeft())\n    if axis.orientation == 'top':\n        return (bounds.bottomLeft(), bounds.bottomRight())\n    if axis.orientation == 'bottom':\n        return (bounds.topLeft(), bounds.topRight())\n    return None\n</code></pre>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis2D.get_line_color","title":"<code>get_line_color(index=None)</code>","text":"<p>Generate line color for given index</p> Source code in <code>mlpyqtgraph/axes.py</code> <pre><code>def get_line_color(self, index=None):\n    \"\"\" Generate line color for given index \"\"\"\n    return self.line_colors[index % len(self.line_colors)]\n</code></pre>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis2D.get_ticks","title":"<code>get_ticks(axis)</code>","text":"<p>Obtain the tick values for a given axis</p> Source code in <code>mlpyqtgraph/axes.py</code> <pre><code>def get_ticks(self, axis):\n    \"\"\" Obtain the tick values for a given axis \"\"\"\n    if axis._tickLevels is not None:\n        return axis._tickLevels  # return manually set ticks\n    length_px = self.get_axis_size(axis)\n    if length_px is None:\n        return []\n    tick_values = axis.tickValues(axis.range[0], axis.range[1], length_px)\n    ticks = list()\n    for (_, values) in tick_values:\n        ticks.extend(values)\n    return sorted(ticks)\n</code></pre>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis2D.set_ticks","title":"<code>set_ticks(axis, major, minor=None)</code>  <code>staticmethod</code>","text":"<p>Sets the major and minor ticks on a given axis</p> Source code in <code>mlpyqtgraph/axes.py</code> <pre><code>@staticmethod\ndef set_ticks(axis, major, minor=None):\n    \"\"\" Sets the major and minor ticks on a given axis \"\"\"\n    if minor is None:\n        minor = ()\n    axis.setTicks([major, minor])\n</code></pre>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis2D.set_xticks","title":"<code>set_xticks(major, minor=None)</code>","text":"<p>Sets the major and minor ticks on the x-axis</p> Source code in <code>mlpyqtgraph/axes.py</code> <pre><code>def set_xticks(self, major, minor=None):\n    \"\"\" Sets the major and minor ticks on the x-axis \"\"\"\n    self.set_ticks(self.x_axis, major, minor)\n</code></pre>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis2D.set_yticks","title":"<code>set_yticks(major, minor=None)</code>","text":"<p>Sets the major and minor ticks on the y-axis</p> Source code in <code>mlpyqtgraph/axes.py</code> <pre><code>def set_yticks(self, major, minor=None):\n    \"\"\" Sets the major and minor ticks on the y-axis \"\"\"\n    self.set_ticks(self.y_axis, major, minor)\n</code></pre>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis2D.setup","title":"<code>setup(padding=0.01)</code>","text":"<p>Setup axes and grid</p> Source code in <code>mlpyqtgraph/axes.py</code> <pre><code>def setup(self, padding=0.01):\n    \"\"\" Setup axes and grid \"\"\"\n    self.show_axis_border('right')\n    self.show_axis_border('top')\n    self.getViewBox().setDefaultPadding(padding=padding)\n    self.getViewBox().rbScaleBox.setPen(fn.mkPen(self.scale_box_line_color, width=2))\n    self.getViewBox().rbScaleBox.setBrush(fn.mkBrush(*self.scale_box_fill_color))\n    for axis_key in self.axes:\n        self.getAxis(axis_key).setZValue(-1) # force axis and corresponding ticks to background\n</code></pre>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis2D.show_axis_border","title":"<code>show_axis_border(axis)</code>","text":"<p>Enables/shows an axis, wihtout values and ticks</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <p>axis string designation, 'left', 'top', 'right' or 'bottom'</p> required Source code in <code>mlpyqtgraph/axes.py</code> <pre><code>def show_axis_border(self, axis):\n    \"\"\" Enables/shows an axis, wihtout values and ticks\n\n    Parameters:\n        axis: axis string designation, 'left', 'top', 'right' or 'bottom'\n    \"\"\"\n    self.showAxis(axis, show=True)\n    self.getAxis(axis).setStyle(showValues=False)\n    self.getAxis(axis).setTicks([(),()])\n</code></pre>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis3D","title":"<code>Axis3D</code>","text":"<p>               Bases: <code>GLGraphicsItem</code></p> <p>3D axis</p> Source code in <code>mlpyqtgraph/axes.py</code> <pre><code>class Axis3D(GLGraphicsItem):\n    \"\"\" 3D axis \"\"\"\n\n    aspect_ratios = {\n        'auto': (1.0, 1.0, 0.8),\n        'flat': (1.0, 1.0, 0.6),\n        'cube': (1.0, 1.0, 1.0),\n    }\n\n    def __init__(self, index, parentItem=None, **kwargs):\n        super().__init__(parentItem=parentItem)\n        antialiasing = options.get_option('antialiasing')\n        self.index = index\n        self.grid_axes = GLGridAxisItem(parentItem=self, line_antialias=antialiasing)\n        self.default_surface_options = {\n            'color': (0, 0, 0, 1),\n            'showGrid': True,\n            'lineAntialias': antialiasing,\n            'colormap': options.get_option('colormap'),\n        }\n        self.default_line_options = {\n            'color': (0, 0, 0, 1),\n            'antialias': antialiasing,\n            'width': 1,\n        }\n        self.default_points_options = {\n            'color': (0, 0, 0, 1),\n            'size': 5.0,\n        }\n        self._items: List[Axis3DItem] = []\n        self._aspect_ratio = 'auto'\n        self._projection_method = options.get_option('projection')\n        self._label_fmt = '.2g'\n        self._lim = { c: [] for c in 'xyz' }\n        self._max_no_ticks = { c: 6 for c in 'xyz' }\n\n    def surf(self, *args, **kwargs):\n        \"\"\" Adds a 3D surface plot item to the view widget  \"\"\"\n        kwargs = dict(self.default_surface_options, **kwargs)\n        surface = GLSurfacePlotItem(**kwargs)\n        self._add_item(surface, *args, **kwargs)\n        self.update()\n\n    def line(self, *args, **kwargs):\n        \"\"\" Plots a single grid line for given coordinates \"\"\"\n        kwargs = dict(self.default_line_options, **kwargs)\n        line = GLLinePlotItem(**kwargs)\n        self._add_item(line, *args, **kwargs)\n        self.update()\n\n    def points(self, *args, **kwargs):\n        \"\"\" Plots a set of points for given coordinates \"\"\"\n        kwargs = dict(self.default_points_options, **kwargs)\n        points = GLPointsItem(**kwargs)\n        self._add_item(points, *args, **kwargs)\n        self.update()\n\n    def update(self):\n        if not self._items:\n            super().update()\n            return\n        aggregated_limits = self._aggregate_limits()\n        shared_limits = self._resolve_limits(aggregated_limits)\n        coords = coords_labels = limits = None\n        for item in self._items:\n            plot_item = item.instance\n            coord_kwargs = dict(zip('xyz', item.data))\n            coords, coords_labels, limits = self._transform_coordinates(\n                coord_kwargs, limits=shared_limits\n            )\n            if isinstance(plot_item, GLSurfacePlotItem):\n                plot_item.setData(**coord_kwargs)\n                if colormap := item.options.get('colormap'):\n                    self._set_colormap(plot_item, colormap_type=colormap)\n            elif isinstance(plot_item, GLLinePlotItem):\n                points = np.column_stack(list(coord_kwargs.values()))\n                plot_item.setData(pos=points)\n            elif isinstance(plot_item, GLPointsItem):\n                points = np.column_stack(list(coord_kwargs.values()))\n                plot_item.setData(pos=points)\n        if coords is not None:\n            # Set FOV based on projection method, distance will be set by best_camera()\n            field_of_view = 60 if self._projection_method == 'perspective' else 1\n            self._get_view().setCameraParams(fov=field_of_view)\n            self.grid_axes.setData(coords=coords, coords_labels=coords_labels, limits=limits)\n            self._get_view().setCameraPosition(\n                **self.grid_axes.best_camera(method=self._projection_method)\n            )\n        super().update()\n\n    def _aggregate_limits(self) -&gt; dict | None:\n        \"\"\"Aggregate min/max limits for each axis across all items.\"\"\"\n        if not self._items:\n            return None\n        mins: dict[str, float | None] = {key: None for key in 'xyz'}\n        maxs: dict[str, float | None] = {key: None for key in 'xyz'}\n        for item in self._items:\n            coord_kwargs = dict(zip('xyz', item.data))\n            for key, values in coord_kwargs.items():\n                values = np.asarray(values)\n                if values.size == 0:\n                    continue\n                min_val = float(values.min())\n                max_val = float(values.max())\n                mins[key] = min_val if mins[key] is None else min(mins[key], min_val)\n                maxs[key] = max_val if maxs[key] is None else max(maxs[key], max_val)\n        return {key: [mins[key], maxs[key]] for key in 'xyz'}\n\n    def _resolve_limits(self, aggregated_limits: dict | None) -&gt; dict:\n        \"\"\"Resolve final limits from custom limits and aggregated data bounds.\"\"\"\n        if aggregated_limits is None:\n            return self._lim\n        resolved = {}\n        for key in 'xyz':\n            user_limits = self._lim.get(key, [])\n            agg_min, agg_max = aggregated_limits[key]\n            min_limit = user_limits[0] if len(user_limits) &gt; 0 else None\n            max_limit = user_limits[1] if len(user_limits) &gt; 1 else None\n            if min_limit is None:\n                min_limit = agg_min\n            if max_limit is None:\n                max_limit = agg_max\n            resolved[key] = [min_limit, max_limit]\n        return resolved\n\n    def _get_view(self) -&gt; GLViewWidget:\n        if view := self.view():\n            return view\n        raise ViewNotDefinedError('Axis3D doesn\\'t have a view!')\n\n    def _add_item(self, item: GLSurfacePlotItem | GLLinePlotItem | GLPointsItem, *data, **options):\n        self._items.append(Axis3DItem(item, data, options))\n        self._get_view().addItem(item)\n\n    def _aspect_coords(self):\n        \"\"\" Returns the aspect ratio coordinates \"\"\"\n        if self._aspect_ratio == 'equal':\n            return False\n        elif isinstance(self._aspect_ratio, str):\n            ratios = self.aspect_ratios.get(self._aspect_ratio, (1.0, 1.0, 0.8))\n        elif isinstance(self._aspect_ratio, tuple | list):\n            ratios = self.aspect_ratio\n        else:\n            raise ValueError()\n        return {label: (0.0, ratio) for label, ratio in zip('xyz', ratios)}\n\n    def _transform_coordinates(self, coord_kwargs, limits=None):\n        \"\"\" Transforms the given coordinates according to fixed coords \"\"\"\n        coords_labels = dict(coord_generator(\n            coord_kwargs,\n            max_no_ticks=self._max_no_ticks,\n            limits=limits if limits is not None else self._lim\n        ))\n        if aspect_coords := self._aspect_coords():\n            coords = {}\n            for key, transformer in coord_transformers(coords_labels, aspect_coords):\n                coord_kwargs[key] = transformer(coord_kwargs[key])\n                coords[key] = transformer(coords_labels[key])\n        else:\n            coords = coords_labels\n        limits = dict(limit_generator(limit_ratio=0.05, **coords))\n        coords_str_labels = dict(self._gen_str_labels(coords_labels))\n        return coords, coords_str_labels, limits\n\n    def _gen_str_labels(self, coords):\n        for key, value in coords.items():\n            yield key, [f'{x:{self._label_fmt}}' for x in value]\n\n    @staticmethod\n    def _set_colormap(surface, colormap_type='CET-L10'):\n        \"\"\" Assign colormap to surface using surface height \"\"\"\n        heights = surface._z\n        normalized_heights = (heights - heights.min())/np.ptp(heights)\n        if current_colormap := colormap.get(colormap_type):\n            colors = current_colormap.map(normalized_heights, mode=ColorMap.FLOAT)\n            surface._meshdata.setFaceColors(colors)\n\n    @property\n    def azimuth(self):\n        \"\"\" Azimuth view angle \"\"\"\n        return self._get_view().cameraParams()['azimuth']\n\n    @azimuth.setter\n    def azimuth(self, value):\n        self._get_view().setCameraParams(azimuth=value)\n\n    @property\n    def elevation(self):\n        \"\"\" Elevation view angle \"\"\"\n        return self._get_view().cameraParams()['elevation']\n\n    @elevation.setter\n    def elevation(self, value):\n        self._get_view().setCameraParams(elevation=value)\n\n    @property\n    def distance(self):\n        \"\"\" View distance \"\"\"\n        return self._get_view().cameraParams()['distance']\n\n    @distance.setter\n    def distance(self, value):\n        self._get_view().setCameraParams(distance=value)\n\n    @property\n    def aspect_ratio(self):\n        \"\"\" Axes and data scaling aspect ratio\n\n        Either a string or a tuple/list.\n\n        - `'auto'`: `(1.0, 1.0, 0.8)`\n        - `'flat'`: `(1.0, 1.0, 0.6)`\n        - `'cube'`: `(1.0, 1.0, 1.0)`\n        - `'equal'`: No scaling, respect data aspect ratio\n        - `tuple` with three floats\n        \"\"\"\n        return self._aspect_ratio\n\n    @aspect_ratio.setter\n    def aspect_ratio(self, ratio='auto'):\n        \"\"\" Set aspect ratio of the 3D axis \"\"\"\n        self._aspect_ratio = ratio\n        self.update()\n\n    @property\n    def projection(self):\n        \"\"\" Projection method, can be either 'perspective' or 'orthographic' \"\"\"\n        return self._projection_method\n\n    @projection.setter\n    def projection(self, projection_method='perspective'):\n        self._projection_method = projection_method\n        self.update()\n\n    @property\n    def label_fmt(self):\n        \"\"\" Number format of the labels, default: '.1f' \"\"\"\n        return self._label_fmt\n\n    @label_fmt.setter\n    def label_fmt(self, fmt: str):\n        self._label_fmt = fmt\n        self.update()\n\n    @property\n    def xlim(self):\n        \"\"\"Custom x-axis limits\"\"\"\n        return self._lim['x']\n\n    @xlim.setter\n    def xlim(self, xlim: list):\n        self._lim['x'] = xlim\n        self.update()\n\n    @property\n    def ylim(self):\n        \"\"\"Custom y-axis limits\"\"\"\n        return self._lim['y']\n\n    @ylim.setter\n    def ylim(self, ylim: list):\n        self._lim['y'] = ylim\n        self.update()\n\n    @property\n    def zlim(self):\n        \"\"\"Custom z-axis limits\"\"\"\n        return self._lim['z']\n\n    @zlim.setter\n    def zlim(self, zlim: list):\n        self._lim['z'] = zlim\n        self.update()\n\n    @staticmethod\n    def _check_ticks(no_ticks):\n        if no_ticks &gt; 1:\n            return no_ticks\n        raise InvalidTicks(\n            f'No. of ticks should be larger than 1, received: {no_ticks}'\n        )\n\n    @property\n    def xticks(self):\n        \"\"\" Approximate number of x-axis ticks\n\n        Should be 2 or larger.\n        \"\"\"\n        return self._max_no_ticks['x']\n\n    @xticks.setter\n    def xticks(self, no_ticks: int):\n        self._max_no_ticks['x'] = self._check_ticks(no_ticks)\n        self.update()\n\n    @property\n    def yticks(self):\n        \"\"\" Approximate number of y-axis ticks\n\n        Should be 2 or larger.\n        \"\"\"\n        return self._max_no_ticks['y']\n\n    @yticks.setter\n    def yticks(self, no_ticks: int):\n        self._max_no_ticks['y'] = self._check_ticks(no_ticks)\n        self.update()\n\n    @property\n    def zticks(self):\n        \"\"\" Approximate number of z-axis ticks\n\n        Should be 2 or larger.\n        \"\"\"\n        return self._max_no_ticks['z']\n\n    @zticks.setter\n    def zticks(self, no_ticks: int):\n        self._max_no_ticks['z'] = self._check_ticks(no_ticks)\n        self.update()\n\n    def export(self, filename):\n        \"\"\" Exports the current view to an image file \"\"\"\n        self._get_view().grabFramebuffer().save(filename)\n\n    def delete(self):\n        \"\"\" Closes the axis \"\"\"\n</code></pre>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis3D.aspect_ratio","title":"<code>aspect_ratio</code>  <code>property</code> <code>writable</code>","text":"<p>Axes and data scaling aspect ratio</p> <p>Either a string or a tuple/list.</p> <ul> <li><code>'auto'</code>: <code>(1.0, 1.0, 0.8)</code></li> <li><code>'flat'</code>: <code>(1.0, 1.0, 0.6)</code></li> <li><code>'cube'</code>: <code>(1.0, 1.0, 1.0)</code></li> <li><code>'equal'</code>: No scaling, respect data aspect ratio</li> <li><code>tuple</code> with three floats</li> </ul>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis3D.azimuth","title":"<code>azimuth</code>  <code>property</code> <code>writable</code>","text":"<p>Azimuth view angle</p>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis3D.distance","title":"<code>distance</code>  <code>property</code> <code>writable</code>","text":"<p>View distance</p>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis3D.elevation","title":"<code>elevation</code>  <code>property</code> <code>writable</code>","text":"<p>Elevation view angle</p>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis3D.label_fmt","title":"<code>label_fmt</code>  <code>property</code> <code>writable</code>","text":"<p>Number format of the labels, default: '.1f'</p>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis3D.projection","title":"<code>projection</code>  <code>property</code> <code>writable</code>","text":"<p>Projection method, can be either 'perspective' or 'orthographic'</p>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis3D.xlim","title":"<code>xlim</code>  <code>property</code> <code>writable</code>","text":"<p>Custom x-axis limits</p>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis3D.xticks","title":"<code>xticks</code>  <code>property</code> <code>writable</code>","text":"<p>Approximate number of x-axis ticks</p> <p>Should be 2 or larger.</p>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis3D.ylim","title":"<code>ylim</code>  <code>property</code> <code>writable</code>","text":"<p>Custom y-axis limits</p>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis3D.yticks","title":"<code>yticks</code>  <code>property</code> <code>writable</code>","text":"<p>Approximate number of y-axis ticks</p> <p>Should be 2 or larger.</p>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis3D.zlim","title":"<code>zlim</code>  <code>property</code> <code>writable</code>","text":"<p>Custom z-axis limits</p>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis3D.zticks","title":"<code>zticks</code>  <code>property</code> <code>writable</code>","text":"<p>Approximate number of z-axis ticks</p> <p>Should be 2 or larger.</p>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis3D.delete","title":"<code>delete()</code>","text":"<p>Closes the axis</p> Source code in <code>mlpyqtgraph/axes.py</code> <pre><code>def delete(self):\n    \"\"\" Closes the axis \"\"\"\n</code></pre>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis3D.export","title":"<code>export(filename)</code>","text":"<p>Exports the current view to an image file</p> Source code in <code>mlpyqtgraph/axes.py</code> <pre><code>def export(self, filename):\n    \"\"\" Exports the current view to an image file \"\"\"\n    self._get_view().grabFramebuffer().save(filename)\n</code></pre>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis3D.line","title":"<code>line(*args, **kwargs)</code>","text":"<p>Plots a single grid line for given coordinates</p> Source code in <code>mlpyqtgraph/axes.py</code> <pre><code>def line(self, *args, **kwargs):\n    \"\"\" Plots a single grid line for given coordinates \"\"\"\n    kwargs = dict(self.default_line_options, **kwargs)\n    line = GLLinePlotItem(**kwargs)\n    self._add_item(line, *args, **kwargs)\n    self.update()\n</code></pre>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis3D.points","title":"<code>points(*args, **kwargs)</code>","text":"<p>Plots a set of points for given coordinates</p> Source code in <code>mlpyqtgraph/axes.py</code> <pre><code>def points(self, *args, **kwargs):\n    \"\"\" Plots a set of points for given coordinates \"\"\"\n    kwargs = dict(self.default_points_options, **kwargs)\n    points = GLPointsItem(**kwargs)\n    self._add_item(points, *args, **kwargs)\n    self.update()\n</code></pre>"},{"location":"reference/axes/#mlpyqtgraph.axes.Axis3D.surf","title":"<code>surf(*args, **kwargs)</code>","text":"<p>Adds a 3D surface plot item to the view widget</p> Source code in <code>mlpyqtgraph/axes.py</code> <pre><code>def surf(self, *args, **kwargs):\n    \"\"\" Adds a 3D surface plot item to the view widget  \"\"\"\n    kwargs = dict(self.default_surface_options, **kwargs)\n    surface = GLSurfacePlotItem(**kwargs)\n    self._add_item(surface, *args, **kwargs)\n    self.update()\n</code></pre>"},{"location":"reference/axes/#mlpyqtgraph.axes.InvalidAxis","title":"<code>InvalidAxis</code>","text":"<p>               Bases: <code>RootException</code></p> <p>Exception raised for invalid axes</p> Source code in <code>mlpyqtgraph/axes.py</code> <pre><code>class InvalidAxis(RootException):\n    \"\"\" Exception raised for invalid axes \"\"\"\n</code></pre>"},{"location":"reference/axes/#mlpyqtgraph.axes.InvalidTicks","title":"<code>InvalidTicks</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised for invalid no. of ticks entries</p> Source code in <code>mlpyqtgraph/axes.py</code> <pre><code>class InvalidTicks(Exception):\n    \"\"\" Raised for invalid no. of ticks entries \"\"\"\n</code></pre>"},{"location":"reference/axes/#mlpyqtgraph.axes.RootException","title":"<code>RootException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Root Exception of the windows module</p> Source code in <code>mlpyqtgraph/axes.py</code> <pre><code>class RootException(Exception):\n    \"\"\" Root Exception of the windows module \"\"\"\n</code></pre>"},{"location":"reference/axes/#mlpyqtgraph.axes.ViewNotDefinedError","title":"<code>ViewNotDefinedError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised if view is not defined yet</p> Source code in <code>mlpyqtgraph/axes.py</code> <pre><code>class ViewNotDefinedError(Exception):\n    \"\"\" Raised if view is not defined yet \"\"\"\n</code></pre>"},{"location":"reference/colors/","title":"Colors","text":"<p>The colors module defines classes to define colors</p>"},{"location":"reference/colors/#mlpyqtgraph.colors.ColorDefinitions","title":"<code>ColorDefinitions</code>","text":"<p>Provide color definitions</p> Source code in <code>mlpyqtgraph/colors.py</code> <pre><code>class ColorDefinitions:\n    \"\"\" Provide color definitions \"\"\"\n    line_colors = {\n        'matlab': (\n            (  0, 113, 188),\n            (216,  82,  24),\n            (118, 171,  47),\n            (236, 176,  31),\n            (125,  46, 141),\n            ( 76, 189, 237),\n            (161,  19,  46),\n            ( 63,  63,  63),\n        ),\n        'matplotlib': (\n            (31,  119, 180),\n            (255, 127,  14),\n            ( 44, 160,  44),\n            (214,  39,  40),\n            (148, 103, 189),\n            (140,  86,  75),\n            (227, 119, 194),\n            (127, 127, 127),\n            (188, 189,  34),\n            (23,  190, 207),\n        ),\n    }\n    scale_box_colors = {\n        'line': (175, 175, 175),\n        'fill': (175, 175, 175, 50),\n    }\n\n    def get_line_colors(self):\n        \"\"\" Returns list of line colors\"\"\"\n        color_profile = options.get_option('line_color_profile')\n        return self.line_colors.get(color_profile, 'matlab')\n\n    def get_scale_box_colors(self, part='line'):\n        \"\"\" Returns scale box colors\"\"\"\n        return self.scale_box_colors[part]\n</code></pre>"},{"location":"reference/colors/#mlpyqtgraph.colors.ColorDefinitions.get_line_colors","title":"<code>get_line_colors()</code>","text":"<p>Returns list of line colors</p> Source code in <code>mlpyqtgraph/colors.py</code> <pre><code>def get_line_colors(self):\n    \"\"\" Returns list of line colors\"\"\"\n    color_profile = options.get_option('line_color_profile')\n    return self.line_colors.get(color_profile, 'matlab')\n</code></pre>"},{"location":"reference/colors/#mlpyqtgraph.colors.ColorDefinitions.get_scale_box_colors","title":"<code>get_scale_box_colors(part='line')</code>","text":"<p>Returns scale box colors</p> Source code in <code>mlpyqtgraph/colors.py</code> <pre><code>def get_scale_box_colors(self, part='line'):\n    \"\"\" Returns scale box colors\"\"\"\n    return self.scale_box_colors[part]\n</code></pre>"},{"location":"reference/config/","title":"Configuration options","text":"<p>The configuration options module defines tools to acquire and change global configuration options</p>"},{"location":"reference/config/#mlpyqtgraph.config.ConfigOptions","title":"<code>ConfigOptions</code>","text":"<p>Holds global configuration options and offers the possibility to changes them</p> Source code in <code>mlpyqtgraph/config.py</code> <pre><code>class ConfigOptions:\n    \"\"\"\n    Holds global configuration options and offers the possibility to changes\n    them\n    \"\"\"\n    config_options = {\n        'line_color_profile': 'matlab',\n        'colormap': 'viridis',\n        'projection': 'perspective',\n        'antialiasing': True,\n        'segmentedLineMode': 'off',\n        'no_segmented_line_mode': False,\n        'black_on_white': True,\n    }\n\n    def __init__(self, **kwargs):\n        self.set_options(**kwargs)\n\n    def set_options(self, **kwargs):\n        \"\"\" Change one or more global configuration options \"\"\"\n        self.config_options = dict(self.config_options, **kwargs)\n        self.enable_pg_options()\n\n    def enable_pg_options(self):\n        \"\"\" Activate pyqtgraph options \"\"\"\n        pg.setConfigOption('background', 'k')\n        pg.setConfigOption('foreground', 'w')\n        if self.config_options['black_on_white']:\n            pg.setConfigOption('background', 'w')\n            pg.setConfigOption('foreground', 'k')\n        pg.setConfigOptions(antialias=self.config_options['antialiasing'])\n        self.config_options['no_segmented_line_mode'] = False\n        try:\n            pg.setConfigOption('segmentedLineMode',\n                               self.config_options['segmentedLineMode'])\n        except KeyError:\n            self.config_options['no_segmented_line_mode'] = True\n\n    def get_option(self, option):\n        \"\"\" Obtain or more global configuration options \"\"\"\n        return self.config_options[option]\n</code></pre>"},{"location":"reference/config/#mlpyqtgraph.config.ConfigOptions.enable_pg_options","title":"<code>enable_pg_options()</code>","text":"<p>Activate pyqtgraph options</p> Source code in <code>mlpyqtgraph/config.py</code> <pre><code>def enable_pg_options(self):\n    \"\"\" Activate pyqtgraph options \"\"\"\n    pg.setConfigOption('background', 'k')\n    pg.setConfigOption('foreground', 'w')\n    if self.config_options['black_on_white']:\n        pg.setConfigOption('background', 'w')\n        pg.setConfigOption('foreground', 'k')\n    pg.setConfigOptions(antialias=self.config_options['antialiasing'])\n    self.config_options['no_segmented_line_mode'] = False\n    try:\n        pg.setConfigOption('segmentedLineMode',\n                           self.config_options['segmentedLineMode'])\n    except KeyError:\n        self.config_options['no_segmented_line_mode'] = True\n</code></pre>"},{"location":"reference/config/#mlpyqtgraph.config.ConfigOptions.get_option","title":"<code>get_option(option)</code>","text":"<p>Obtain or more global configuration options</p> Source code in <code>mlpyqtgraph/config.py</code> <pre><code>def get_option(self, option):\n    \"\"\" Obtain or more global configuration options \"\"\"\n    return self.config_options[option]\n</code></pre>"},{"location":"reference/config/#mlpyqtgraph.config.ConfigOptions.set_options","title":"<code>set_options(**kwargs)</code>","text":"<p>Change one or more global configuration options</p> Source code in <code>mlpyqtgraph/config.py</code> <pre><code>def set_options(self, **kwargs):\n    \"\"\" Change one or more global configuration options \"\"\"\n    self.config_options = dict(self.config_options, **kwargs)\n    self.enable_pg_options()\n</code></pre>"},{"location":"reference/ml_functions/","title":"Matplotlib-like functions","text":"<p>Matplotlib-like functions for easy figure and plot definitions</p>"},{"location":"reference/ml_functions/#mlpyqtgraph.ml_functions.close","title":"<code>close(figure_ref)</code>","text":"<p>Closes the provided figure and deletes it</p> Source code in <code>mlpyqtgraph/ml_functions.py</code> <pre><code>def close(figure_ref):\n    \"\"\" Closes the provided figure and deletes it \"\"\"\n    gcf().close(figure_ref)\n</code></pre>"},{"location":"reference/ml_functions/#mlpyqtgraph.ml_functions.figure","title":"<code>figure(*args, **kwargs)</code>","text":"<p>Create, raise or modify FigureWorker objects</p> Source code in <code>mlpyqtgraph/ml_functions.py</code> <pre><code>def figure(*args, **kwargs):\n    \"\"\" Create, raise or modify FigureWorker objects \"\"\"\n    container = refs.worker.get('figure')\n    if not args:\n        return container.create(**kwargs)\n    figure_worker = args[0]\n    figure_worker.activate()\n    container.current = figure_worker\n    return figure_worker\n</code></pre>"},{"location":"reference/ml_functions/#mlpyqtgraph.ml_functions.gca","title":"<code>gca()</code>","text":"<p>Returns the current axis</p> Source code in <code>mlpyqtgraph/ml_functions.py</code> <pre><code>def gca():\n    \"\"\" Returns the current axis \"\"\"\n    container = refs.worker.get('axis')\n    if container.current is None:\n        figure()  # make sure we always have a figure\n    return container.current\n</code></pre>"},{"location":"reference/ml_functions/#mlpyqtgraph.ml_functions.gcf","title":"<code>gcf()</code>","text":"<p>Returns the current figure</p> Source code in <code>mlpyqtgraph/ml_functions.py</code> <pre><code>def gcf():\n    \"\"\" Returns the current figure \"\"\"\n    container = refs.worker.get('figure')\n    if container.current is None:\n        figure()  # make sure we always have a figure\n    return container.current\n</code></pre>"},{"location":"reference/ml_functions/#mlpyqtgraph.ml_functions.legend","title":"<code>legend(*args)</code>","text":"<p>Adds a legend to the current figure</p> Source code in <code>mlpyqtgraph/ml_functions.py</code> <pre><code>def legend(*args):\n    \"\"\" Adds a legend to the current figure \"\"\"\n    gca().add_legend(*args)\n</code></pre>"},{"location":"reference/ml_functions/#mlpyqtgraph.ml_functions.plot","title":"<code>plot(*args, **kwargs)</code>","text":"<p>Plots into the current axis</p> Source code in <code>mlpyqtgraph/ml_functions.py</code> <pre><code>def plot(*args, **kwargs):\n    \"\"\" Plots into the current axis \"\"\"\n    gcf().create_axis(axis_type='2D')\n    return gca().add(*args, **kwargs)\n</code></pre>"},{"location":"reference/ml_functions/#mlpyqtgraph.ml_functions.plot3","title":"<code>plot3(*args, **kwargs)</code>","text":"<p>Plots a 3D line</p> Source code in <code>mlpyqtgraph/ml_functions.py</code> <pre><code>def plot3(*args, **kwargs):\n    \"\"\" Plots a 3D line \"\"\"\n    gcf().change_layout('Qt')\n    gcf().create_axis(axis_type='3D')\n    gca().line(*args, **kwargs)\n</code></pre>"},{"location":"reference/ml_functions/#mlpyqtgraph.ml_functions.points3","title":"<code>points3(*args, **kwargs)</code>","text":"<p>Plots 3D points</p> Source code in <code>mlpyqtgraph/ml_functions.py</code> <pre><code>def points3(*args, **kwargs):\n    \"\"\" Plots 3D points \"\"\"\n    gcf().change_layout('Qt')\n    gcf().create_axis(axis_type='3D')\n    gca().points(*args, **kwargs)\n</code></pre>"},{"location":"reference/ml_functions/#mlpyqtgraph.ml_functions.surf","title":"<code>surf(*args, **kwargs)</code>","text":"<p>Plots a 3D surface</p> Source code in <code>mlpyqtgraph/ml_functions.py</code> <pre><code>def surf(*args, **kwargs):\n    \"\"\" Plots a 3D surface \"\"\"\n    gcf().change_layout('Qt')\n    gcf().create_axis(axis_type='3D')\n    gca().surf(*args, **kwargs)\n</code></pre>"},{"location":"reference/windows/","title":"Windows","text":"<p>This module contains all classes for handling the GUI figures and axes in mlpyqtgraph</p>"},{"location":"reference/windows/#mlpyqtgraph.windows.Figure2DWindow","title":"<code>Figure2DWindow</code>","text":"<p>               Bases: <code>FigureWindow</code></p> <p>Controls a 2D figure window instance</p> Source code in <code>mlpyqtgraph/windows.py</code> <pre><code>class Figure2DWindow(FigureWindow):\n    \"\"\" Controls a 2D figure window instance \"\"\"\n</code></pre>"},{"location":"reference/windows/#mlpyqtgraph.windows.Figure3DWindow","title":"<code>Figure3DWindow</code>","text":"<p>               Bases: <code>FigureWindow</code></p> <p>Controls a 3D figure window instance</p> Source code in <code>mlpyqtgraph/windows.py</code> <pre><code>class Figure3DWindow(FigureWindow):\n    \"\"\" Controls a 3D figure window instance \"\"\"\n</code></pre>"},{"location":"reference/windows/#mlpyqtgraph.windows.FigureWindow","title":"<code>FigureWindow</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Controls a figure window instance</p> Source code in <code>mlpyqtgraph/windows.py</code> <pre><code>class FigureWindow(QtCore.QObject):\n    \"\"\" Controls a figure window instance \"\"\"\n    triggered = QtCore.Signal()\n    axis_factory = None\n\n    def __init__(self, index, title='Figure', width=600, height=500, layout_type='pg', parent=None):\n        super().__init__(parent=parent)\n        self.index = index\n        self.layout_type = None\n        self.window = self.setup_window(parent, width, height)\n        self.change_layout(layout_type)\n        self.title = f'Figure {index+1}: {title}'\n        self.window.show()\n\n    def setup_window(self, parent, width, height):\n        \"\"\" Setup the figure window as QMainWindow \"\"\"\n        window = QtWidgets.QMainWindow(parent)\n        window.resize(width, height)\n        return window\n\n    def change_layout(self, layout_type='pg'):\n        \"\"\"\n        Change the figure's layout type; 'pg' for pyqtgraph's native layout or 'Qt'\n        layout.\n\n        Returns: boolean indicating layout change\n        \"\"\"\n        if self.layout_type == layout_type:\n            return False\n        self.layout_type = layout_type\n        LayoutWidget = pg.GraphicsLayoutWidget\n        if layout_type == 'Qt':\n            LayoutWidget = pg.opengl.GLViewWidget\n        self.window.setCentralWidget(LayoutWidget())\n        return True\n\n    def add_axis(self, index):\n        \"\"\" Adds an axis to the figure \"\"\"\n        axis = refs.gui.get('axis').items[index]\n        self.graphics_layout.addItem(axis)\n\n    @property\n    def graphics_layout(self):\n        \"\"\" Returns the GraphicsLayoutWidget \"\"\"\n        return self.window.centralWidget()\n\n    @property\n    def title(self):\n        \"\"\" Figure window title \"\"\"\n        return self.window.windowTitle()\n\n    @title.setter\n    def title(self, new_title):\n        self.window.setWindowTitle(new_title)\n\n    @property\n    def width(self):\n        \"\"\" Figure window width \"\"\"\n        return self.window.width()\n\n    @width.setter\n    def width(self, width):\n        self.window.resize(width, self.height)\n\n    @property\n    def height(self):\n        \"\"\" Figure window height \"\"\"\n        return self.window.height()\n\n    @height.setter\n    def height(self, height):\n        self.window.resize(self.width, height)\n\n    def raise_window(self):\n        \"\"\" Raises the current window to top \"\"\"\n        if sys.platform == 'win32':\n            state = self.window.windowState() &amp; ~QtCore.Qt.WindowMinimized | QtCore.Qt.WindowActive\n            self.window.setWindowState(state)\n            self.window.activateWindow()\n        else:\n            self.window.raise_()\n\n    def delete(self):\n        \"\"\" Closes the window \"\"\"\n        self.window.close()\n</code></pre>"},{"location":"reference/windows/#mlpyqtgraph.windows.FigureWindow.graphics_layout","title":"<code>graphics_layout</code>  <code>property</code>","text":"<p>Returns the GraphicsLayoutWidget</p>"},{"location":"reference/windows/#mlpyqtgraph.windows.FigureWindow.height","title":"<code>height</code>  <code>property</code> <code>writable</code>","text":"<p>Figure window height</p>"},{"location":"reference/windows/#mlpyqtgraph.windows.FigureWindow.title","title":"<code>title</code>  <code>property</code> <code>writable</code>","text":"<p>Figure window title</p>"},{"location":"reference/windows/#mlpyqtgraph.windows.FigureWindow.width","title":"<code>width</code>  <code>property</code> <code>writable</code>","text":"<p>Figure window width</p>"},{"location":"reference/windows/#mlpyqtgraph.windows.FigureWindow.add_axis","title":"<code>add_axis(index)</code>","text":"<p>Adds an axis to the figure</p> Source code in <code>mlpyqtgraph/windows.py</code> <pre><code>def add_axis(self, index):\n    \"\"\" Adds an axis to the figure \"\"\"\n    axis = refs.gui.get('axis').items[index]\n    self.graphics_layout.addItem(axis)\n</code></pre>"},{"location":"reference/windows/#mlpyqtgraph.windows.FigureWindow.change_layout","title":"<code>change_layout(layout_type='pg')</code>","text":"<p>Change the figure's layout type; 'pg' for pyqtgraph's native layout or 'Qt' layout.</p> <p>Returns: boolean indicating layout change</p> Source code in <code>mlpyqtgraph/windows.py</code> <pre><code>def change_layout(self, layout_type='pg'):\n    \"\"\"\n    Change the figure's layout type; 'pg' for pyqtgraph's native layout or 'Qt'\n    layout.\n\n    Returns: boolean indicating layout change\n    \"\"\"\n    if self.layout_type == layout_type:\n        return False\n    self.layout_type = layout_type\n    LayoutWidget = pg.GraphicsLayoutWidget\n    if layout_type == 'Qt':\n        LayoutWidget = pg.opengl.GLViewWidget\n    self.window.setCentralWidget(LayoutWidget())\n    return True\n</code></pre>"},{"location":"reference/windows/#mlpyqtgraph.windows.FigureWindow.delete","title":"<code>delete()</code>","text":"<p>Closes the window</p> Source code in <code>mlpyqtgraph/windows.py</code> <pre><code>def delete(self):\n    \"\"\" Closes the window \"\"\"\n    self.window.close()\n</code></pre>"},{"location":"reference/windows/#mlpyqtgraph.windows.FigureWindow.raise_window","title":"<code>raise_window()</code>","text":"<p>Raises the current window to top</p> Source code in <code>mlpyqtgraph/windows.py</code> <pre><code>def raise_window(self):\n    \"\"\" Raises the current window to top \"\"\"\n    if sys.platform == 'win32':\n        state = self.window.windowState() &amp; ~QtCore.Qt.WindowMinimized | QtCore.Qt.WindowActive\n        self.window.setWindowState(state)\n        self.window.activateWindow()\n    else:\n        self.window.raise_()\n</code></pre>"},{"location":"reference/windows/#mlpyqtgraph.windows.FigureWindow.setup_window","title":"<code>setup_window(parent, width, height)</code>","text":"<p>Setup the figure window as QMainWindow</p> Source code in <code>mlpyqtgraph/windows.py</code> <pre><code>def setup_window(self, parent, width, height):\n    \"\"\" Setup the figure window as QMainWindow \"\"\"\n    window = QtWidgets.QMainWindow(parent)\n    window.resize(width, height)\n    return window\n</code></pre>"},{"location":"reference/windows/#mlpyqtgraph.windows.NoFigureException","title":"<code>NoFigureException</code>","text":"<p>               Bases: <code>RootException</code></p> <p>This Exception is raised if no figure is defined, although one is requested</p> Source code in <code>mlpyqtgraph/windows.py</code> <pre><code>class NoFigureException(RootException):\n    \"\"\" This Exception is raised if no figure is defined, although one is requested \"\"\"\n</code></pre>"},{"location":"reference/windows/#mlpyqtgraph.windows.NoFigureLayout","title":"<code>NoFigureLayout</code>","text":"<p>               Bases: <code>RootException</code></p> <p>This Exception is raised the figure layout has not been set</p> Source code in <code>mlpyqtgraph/windows.py</code> <pre><code>class NoFigureLayout(RootException):\n    \"\"\" This Exception is raised the figure layout has not been set \"\"\"\n</code></pre>"},{"location":"reference/windows/#mlpyqtgraph.windows.RootException","title":"<code>RootException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Root Exception of the windows module</p> Source code in <code>mlpyqtgraph/windows.py</code> <pre><code>class RootException(Exception):\n    \"\"\" Root Exception of the windows module \"\"\"\n</code></pre>"},{"location":"reference/worker/","title":"Workers","text":"<p>This modules defines all worker thread related classes and instances</p>"},{"location":"reference/worker/#mlpyqtgraph.workers.AxisWorker","title":"<code>AxisWorker</code>","text":"<p>               Bases: <code>WorkerItem</code></p> <p>Worker thread axis to Control AxisWidget on the GUI thread</p> Source code in <code>mlpyqtgraph/workers.py</code> <pre><code>class AxisWorker(containers.WorkerItem):\n    \"\"\" Worker thread axis to Control AxisWidget on the GUI thread \"\"\"\n    factory = containers.WorkerItem.get_factory()\n    row = factory.attribute()\n    column = factory.attribute()\n    add = factory.method()\n    surf = factory.method()\n    line = factory.method()\n    points = factory.method()\n    add_legend = factory.method()\n    grid = factory.attribute()\n    xlim = factory.attribute()\n    ylim = factory.attribute()\n    xlabel = factory.attribute()\n    ylabel = factory.attribute()\n    xticks = factory.attribute()\n    yticks = factory.attribute()\n    set_xticks = factory.method()\n    set_yticks = factory.method()\n    azimuth = factory.attribute()\n    elevation = factory.attribute()\n    distance = factory.attribute()\n    aspect_ratio = factory.attribute()\n    projection = factory.attribute()\n    label_fmt = factory.attribute()\n    xlim = factory.attribute()\n    ylim = factory.attribute()\n    zlim = factory.attribute()\n    xticks = factory.attribute()\n    yticks = factory.attribute()\n    zticks = factory.attribute()\n    export = factory.method()\n</code></pre>"},{"location":"reference/worker/#mlpyqtgraph.workers.FigureWorker","title":"<code>FigureWorker</code>","text":"<p>               Bases: <code>WorkerItem</code></p> <p>Worker thread figure to control FigureWindow on the GUI thread</p> Source code in <code>mlpyqtgraph/workers.py</code> <pre><code>class FigureWorker(containers.WorkerItem):\n    \"\"\" Worker thread figure to control FigureWindow on the GUI thread\"\"\"\n    factory = containers.WorkerItem.get_factory()\n    width = factory.attribute()\n    height = factory.attribute()\n    raise_window = factory.method()\n    change_layout = factory.method()\n    add_axis = factory.method()\n    has_axis = factory.method()\n\n    def __init__(self, *args, **kwargs):\n        self.axis = None\n        super().__init__(*args, **kwargs)\n\n    def create_axis(self, *args, **kwargs):\n        \"\"\" Adds an axis to the figure worker \"\"\"\n        if self.axis:\n            return\n        axis_container = refs.worker.get('axis')\n        axis = axis_container.create(**kwargs)\n        index = axis.index\n        self.add_axis(index)\n        self.axis = axis\n</code></pre>"},{"location":"reference/worker/#mlpyqtgraph.workers.FigureWorker.create_axis","title":"<code>create_axis(*args, **kwargs)</code>","text":"<p>Adds an axis to the figure worker</p> Source code in <code>mlpyqtgraph/workers.py</code> <pre><code>def create_axis(self, *args, **kwargs):\n    \"\"\" Adds an axis to the figure worker \"\"\"\n    if self.axis:\n        return\n    axis_container = refs.worker.get('axis')\n    axis = axis_container.create(**kwargs)\n    index = axis.index\n    self.add_axis(index)\n    self.axis = axis\n</code></pre>"}]}